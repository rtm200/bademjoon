<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bademjoon</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <main id="main">
        <div class="title">
            <span id="remains"></span>
            <h2>بادمجون</h2>
        </div>
        <div class="words">
            <span>پ</span>
            <span class="words-line"></span>
            <span>ل</span>
            <span class="words-line"></span>
            <span>و</span>
            <span class="words-line"></span>
            <span>ا</span>
            <span class="words-line"></span>
            <span>د</span>
            <span class="words-line"></span>
            <span>ر</span>
        </div>
        <div id="otp-input" class="font-h2-strong" dir="rtl">
            <input class="font-h2-strong" step="1"  autocomplete="no" pattern="\d*" />
            <input class="font-h2-strong" step="1"  autocomplete="no" pattern="\d*" />
            <input class="font-h2-strong" step="1"  autocomplete="no" pattern="\d*" />
            <input class="font-h2-strong" step="1"  autocomplete="no" pattern="\d*" />
            <input class="font-h2-strong" step="1"  autocomplete="no" pattern="\d*" />
            <input class="font-h2-strong" step="1"  autocomplete="no" pattern="\d*" />
            <input id="otp-value" type="hidden" name="otp" />
        </div>

        <div class="buttonField">
            <button id="submit">منو بمال</button>
        </div>
    </main>
    <div id="bademjoon" class="bademjoon">
        <img src="bademjoon.png">
    </div>
</body>
<script>
    window.addEventListener("load", function () {
        const OTPContainer = document.querySelector("#otp-input");
        const OTPValueContainer = document.querySelector("#otp-value");
        const continueButton = document.querySelector("#submit");
        const gameWords = ["پلو", "راد", "لوپ"];
        
        function updateRemainingWords() {
            const remainingWords = gameWords.length;
            const remainsElement = document.getElementById("remains");
            if (remainsElement) {
                remainsElement.textContent = remainingWords;
            }
            return remainingWords;
        }

        function checkGameStatus() {
            if (updateRemainingWords() === 0) {
                const main = document.querySelector("#main");
                const bademjoon = document.querySelector("#bademjoon");
                if (main) {
                    main.style.display = "none";
                    bademjoon.style.display = "flex";
                }
            }
        }

        updateRemainingWords();

        continueButton.addEventListener("click", (e) => {
            updateValue(inputs);
            const inputValue = OTPValueContainer.value.trim();

            const wordIndex = gameWords.indexOf(inputValue);

            if (wordIndex !== -1) {
                gameWords.splice(wordIndex, 1); 
                alert('ok');
            } else {
                alert('wrong');
            }

            checkGameStatus();
        });
        const firstInput = OTPContainer.querySelector("input");
        firstInput.focus();

        const updateValue = (inputs) => {
            OTPValueContainer.value = Array.from(inputs).reduce((acc, curInput) => acc.concat(curInput.value ? curInput.value : " "), "");
        };

        const isValidInput = (inputValue) => {
            return Number(inputValue) === 0 && inputValue !== "0" ? false : true;
        };

        const setInputValue = (inputElement, inputValue) => {
            inputElement.value = inputValue;
        };

        const resetInput = (inputElement) => {
            setInputValue(inputElement, "");
        };

        const focusNext = (inputs, curIndex) => {
            const nextElement = curIndex < inputs.length - 1 ? inputs[curIndex + 1] : inputs[curIndex];

            nextElement.focus();
            nextElement.select();
        };

        const focusPrev = (inputs, curIndex) => {
            const prevElement = curIndex > 0 ? inputs[curIndex - 1] : inputs[curIndex];

            prevElement.focus();
            prevElement.select();
        };

        const focusIndex = (inputs, index) => {
            const element = index < inputs.length - 1 ? inputs[index] : inputs[inputs.length - 1];

            element.focus();
            element.select();
        };

        const handleValidMultiInput = (inputElement, inputValue, curIndex, inputs) => {
            const inputLength = inputValue.length;
            const numInputs = inputs.length;

            const endIndex = Math.min(curIndex + inputLength - 1, numInputs - 1);
            const inputsToChange = Array.from(inputs).slice(curIndex, endIndex + 1);
            inputsToChange.forEach((input, index) => setInputValue(input, inputValue[index]));
            focusIndex(inputs, endIndex);
        };

        const handleInput = (inputElement, inputValue, curIndex, inputs) => {
            if (!isValidInput(inputValue)) return handleInvalidInput(inputElement);
            if (inputValue.length === 1) handleValidSingleInput(inputElement, inputValue, curIndex, inputs);
            else handleValidMultiInput(inputElement, inputValue, curIndex, inputs);
        };

        const handleValidSingleInput = (inputElement, inputValue, curIndex, inputs) => {
            setInputValue(inputElement, inputValue.slice(-1));
            focusNext(inputs, curIndex);
        };

        const handleInvalidInput = (inputElement) => {
            resetInput(inputElement);
        };

        const handleKeyDown = (event, key, inputElement, curIndex, inputs) => {
            if (key === "Delete") {
                resetInput(inputElement);
                focusPrev(inputs, curIndex);
            }
            if (key === "ArrowLeft") {
                event.preventDefault();
                focusPrev(inputs, curIndex);
            }
            if (key === "ArrowRight") {
                event.preventDefault();
                focusNext(inputs, curIndex);
            }
        };

        const handleDelete = (inputElement, curIndex, inputs) => {};

        const handleKeyUp = (event, key, inputElement, curIndex, inputs) => {
            if (key === "Backspace") focusPrev(inputs, curIndex);
        };

        const inputs = OTPContainer.querySelectorAll("input:not(#otp-value)");
        inputs.forEach((input, index) => {
            input.addEventListener("input", (e) => handleInput(input, e.target.value, index, inputs));

            input.addEventListener("keydown", (e) => handleKeyDown(e, e.key, input, index, inputs));

            input.addEventListener("keyup", (e) => handleKeyUp(e, e.key, input, index, inputs));

            input.addEventListener("focus", (e) => e.target.select());
        });
    });
</script>
</html>